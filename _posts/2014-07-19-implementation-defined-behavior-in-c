---
layout: post
title: Implementation-defined Behavior in C
tags: C semantics
published: False
---

I've become interested recently in how we should think (and reason) about C programs that perform implementation-defined operations (in particular, conversions between nonnull pointers and integers). 

Mostly, this is just idle curiosity on my part. 

On the other hand, there are some interesting issues surrounding implementation-defined behavior, portability, and formal models of compiler correctness. I don't go deep into these issues here---this post is mostly just a high-level overview, with some unanswered questions.

First, definitions: 

### Implementation-defined Behavior

The C11 standard defines "implementation-defined behavior" as 
> unspecified behavior where each implementation documents how the choice is made.
> (3.4.1, [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf](C11 draft standard))

### Unspecified Behavior 

"Unspecified behavior" (3.4.4), in turn, either has two or more possible specified outcomes (e.g., order of evaluation of function arguments), or involves the use of an "unspecified value," which is any valid value of the relevant type (int, float, etc.). 

### Examples

Implementation-defined:
* pointer-to-integer (and integer-to-pointer) conversions, whenever the pointer/integer is nonnull/nonzero
* representation of signed integers (two's complement, one's complement, etc.)
* the extent to which the compiler respects the inline function specifier
* ... and many more ... (J.3)

Unspecified:
* the order in which subexpressions are evaluated (and the order in which any resulting side-effects occur) in function calls, evaluation of &&, ||, ?:, and comma operators
* the order in which # and ## operations are evaluated during preprocessing
* ... and many more ... (J.1)

### Integer-Pointer Conversions

The most interesting kind of implementation-defined behavior, from my perspective, is conversion between (void, nonnull) pointers and integers, via explicit casts as in the program below:

``` C
#include <stddef.h>

int g(int* x) {
  return ((uintptr_t)x <= 0xbffff980);
}

static inline int f(void) {
  int a = 0;
  return g(&a);
}

int main(void) {
  return f();
}
```

When we're (mentally) computing the effect of some piece of C code, as it would execute in the C abstract machine, think of unspecified behavior as _nondeterministic_ (we need to consider all possibilities) and 

If we want to treat these programs as portable C codes, and (mentally) compute their behavior just from the standard (i.e., without reference to any particular compiler), what do we do when try to compute the result of one of these integer--pointer conversions?

One option is to say the implementation is arbitrary, or unconstrained. But then it becomes really difficult to prove anything about a program that uses an integer--pointer cast.

Another option is to pick a particular implementation a priori. But then the property we've proved holds only when the C program is compiled with a particular compiler, and we lose portability.

CompCert C follows a third path: get stuck on the following code:

#include <stdio.h>

int g(unsigned int* x) {
  return ((unsigned int)x <= 0xbffff980);
}

static inline unsigned int f(void) {
  unsigned int a = 0;
  return g(&a);
}

int main(void) {
  printf("%x\n", f());
  return 0;
}

If you run this in the CompCert C interpreter (ccomp -interp), you get:

Stuck state: in function g, expression <ptr> <= -1073743488
Stuck subexpression: <ptr> <= -1073743488
ERROR: Undefined behavior

at this point in g:

  return ((unsigned int)x <= 0xbffff980);

The cast to unsigned int leaves the Vptr a Vptr (because it's a neutral cast). The comparison then gets stuck.

A question: Is getting stuck a valid unspecified behavior?

(Incidentally, this program on my machine returns 0 or 1, depending on whether I tell CompCert to inline the function f :-))

So, my thinking in general is that nonportable C code is just bad :-)

